# bot_mines.py
import time
import random
import logging
from telegram import Update, ParseMode, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Updater, CommandHandler, CallbackContext, MessageHandler, Filters, CallbackQueryHandler

# ========== CONFIG ==========
TOKEN = "8272197234:AAHpVytSM3IAkjvcuQp6nyN9gKiolKLu3t4"           # <-- Mets ici ton nouveau token (NE PAS le partager)
TON_ID_ADMIN = 7530082416         # <-- Ton ID Telegram (admin)
INSCRIPTION_LINK = "https://1wlucb.life/v3/aggressive-casino?p=naub"
CANAL_LINK = "https://t.me/+neQ37IL3AiEzOTBk"
CONTACT_TELEGRAM = "https://t.me/amour20251"  # lien pour "Achetez"

# ========== LOGGING ==========
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ========== DONN√âES EN M√âMOIRE ==========
# Structure users[user_id] = {
#   "status": "bloque" | "actif",
#   "pred_left": int,
#   "last_prediction_ts": float (epoch secs) or 0,
#   "last_message_id": int or None
# }
users = {}

# ========== UTIL ==========

def ensure_user(uid):
    if uid not in users:
        users[uid] = {"status": "bloque", "pred_left": 20, "last_prediction_ts": 0, "last_message_id": None}

def make_start_message():
    text = (
        "<b>Gagne de l'argent sur BombMaker 1WIN</b>\n\n"
        "Gr√¢ce √† la nouvelle version de ChatGPT qui analyse le jeu, ce bot te propose des signaux Mines.\n\n"
        "üîπ Rapide\nüîπ Automatis√©\nüîπ Facile √† utiliser\n\n"
        "Appuie sur <b>Commence</b> pour voir les instructions et t'inscrire."
    )
    keyboard = [[InlineKeyboardButton("Commence", callback_data="commence")]]
    return text, InlineKeyboardMarkup(keyboard)

def make_1win_message():
    text = (
        "COMMENT AVOIR UN COMPTE 1WINüáÆüáπ AUTHENTIQUE:.. üÜô\n\n"
        "GUIDE EN IMAGE ‚Ä¶.‚ÄºÔ∏è‚ÄºÔ∏è\n"
        "‚úçÔ∏è‚úçÔ∏è‚úçÔ∏è‚úçÔ∏è‚úçÔ∏è\n"
        "Pour gagner gros il faut avoir un compte professionnel et un algorithme tr√®s bas et pour cela je te conseille le code promoüëá\n"
        "Code promo‚û°Ô∏è VVIP250 ‚≠êÔ∏è \n\n"
        "1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£4Ô∏è‚É£5Ô∏è‚É£6Ô∏è‚É£7Ô∏è‚É£8Ô∏è‚É£9Ô∏è‚É£\n"
        "Recharge toi gros afin que tu puisses gagner minimum 50.000F √† 100.000F par jours ‚úçÔ∏è\n\n"
        f"üáÆüáπLien d‚Äôinscription üîõ {INSCRIPTION_LINK}\n\n"
        "üëâ Maintenant, envoie-moi ton ID de compte 1WIN."
    )
    keyboard = [
        [InlineKeyboardButton("Inscription", url=INSCRIPTION_LINK)],
        [InlineKeyboardButton("V√©rifier (envoyer ID)", callback_data="ask_id")],
    ]
    return text, InlineKeyboardMarkup(keyboard)

# ========== HANDLERS ==========

def start_cmd(update: Update, context: CallbackContext):
    user = update.effective_user
    ensure_user(user.id)
    text, markup = make_start_message()
    update.message.reply_text(text, parse_mode=ParseMode.HTML, reply_markup=markup)

def button_callback(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    data = query.data
    uid = query.from_user.id

    if data == "commence":
        # envoyer le message 1WIN avec boutons
        text, markup = make_1win_message()
        query.message.reply_text(text, parse_mode=ParseMode.HTML, reply_markup=markup)
    elif data == "ask_id":
        # demander √† l'utilisateur d'envoyer son ID 1WIN (texte)
        context.bot.send_message(chat_id=uid, text="üìù Envoie-moi maintenant ton ID 1WIN (texte). Si tu veux, pr√©cise aussi combien d'amis tu as invit√©s.")
    elif data.startswith("admin_validate_"):
        # admin clique sur Valider d'une notification
        parts = data.split("_")
        if len(parts) >= 3:
            target_id = int(parts[2])
            if query.from_user.id != TON_ID_ADMIN:
                query.message.reply_text("üö´ Tu n'es pas admin.")
                return
            # valider
            ensure_user(target_id)
            users[target_id]["status"] = "actif"
            users[target_id]["pred_left"] = 20
            context.bot.send_message(chat_id=target_id, text="‚úÖ Ton compte a √©t√© valid√© par l'admin. Tu peux utiliser /prediction ou appuyer sur Prochaine cote.")
            query.message.reply_text(f"‚úÖ Utilisateur {target_id} valid√©.")
    elif data.startswith("admin_refuse_"):
        parts = data.split("_")
        target_id = int(parts[2])
        if query.from_user.id != TON_ID_ADMIN:
            query.message.reply_text("üö´ Tu n'es pas admin.")
            return
        # refuser
        context.bot.send_message(chat_id=target_id, text="‚ùå Ta demande a √©t√© refus√©e par l'admin.")
        query.message.reply_text(f"‚ùå Utilisateur {target_id} refus√©.")
    elif data.startswith("admin_confirm_buy_"):
        parts = data.split("_")
        target_id = int(parts[3])
        if query.from_user.id != TON_ID_ADMIN:
            query.message.reply_text("üö´ Tu n'es pas admin.")
            return
        # accorder par exemple 20 pr√©dictions suppl√©mentaires
        ensure_user(target_id)
        users[target_id]["pred_left"] += 20
        context.bot.send_message(chat_id=target_id, text="‚úÖ Achat confirm√© par l'admin ‚Äî 20 pr√©dictions ajout√©es √† ton compte.")
        query.message.reply_text(f"‚úÖ Achat confirm√© pour {target_id}, 20 signaux ajout√©s.")

def handle_text(update: Update, context: CallbackContext):
    uid = update.effective_user.id
    text = update.message.text.strip()

    # commande texte "Prochaine cote" ou "cote" d√©clenche prediction
    if text.lower().find("prochaine cote") != -1 or text.lower().find("cote") != -1:
        return prediction_cmd(update, context)

    # si utilisateur dit "j'ai invit√©" -> notifier admin (user peut pr√©ciser nb d'amis)
    if "jai invite" in text.lower() or "j'ai invit√©" in text.lower() or "j ai invit√©" in text.lower():
        # envoyer message admin avec boutons valider/refuser
        ensure_user(uid)
        # on permet √† l'utilisateur d'ajouter un nombre dans le m√™me texte (ex: "j'ai invit√© 2")
        invited_count = None
        for word in text.split():
            if word.isdigit():
                invited_count = int(word)
                break
        msg = f"üì© L'utilisateur {uid} dit avoir invit√© {invited_count if invited_count else 'des amis'}. \nID: {uid}\nTape /valider {uid} pour valider ou utilise les boutons ci-dessous."
        keyboard = [
            [
                InlineKeyboardButton("Valider", callback_data=f"admin_validate_{uid}"),
                InlineKeyboardButton("Refuser", callback_data=f"admin_refuse_{uid}")
            ]
        ]
        context.bot.send_message(chat_id=TON_ID_ADMIN, text=msg, reply_markup=InlineKeyboardMarkup(keyboard))
        update.message.reply_text("‚úÖ Message envoy√© √† l'admin. Attends la validation.")
        return

    # Si c'est un ID (on suppose que l'utilisateur a envoy√© son ID 1WIN apr√®s avoir cliqu√© V√©rifier)
    # heuristique: si le message contient uniquement chiffres ou alphanum et longueur raisonnable => on l'accepte comme ID
    if text and len(text) <= 60:
        # enregistrer comme id_1win et pr√©venir admin
        ensure_user(uid)
        users[uid]["id_1win"] = text
        # notifier admin avec bouton valider
        msg = f"üì© Nouvel envoi d'ID 1WIN:\nUser: {uid}\nID 1WIN: {text}\n\nValide si ok."
        keyboard = [
            [
                InlineKeyboardButton("Valider", callback_data=f"admin_validate_{uid}"),
                InlineKeyboardButton("Refuser", callback_data=f"admin_refuse_{uid}")
            ]
        ]
        context.bot.send_message(chat_id=TON_ID_ADMIN, text=msg, reply_markup=InlineKeyboardMarkup(keyboard))
        update.message.reply_text("‚úÖ Merci, ton ID a √©t√© re√ßu. Je vais le signaler √† l'admin pour validation.")
        # envoyer instruction invite canal et lien d'invite (user devra inviter, admin valide manuellement)
        invite_link = f"https://t.me/{context.bot.username}?start={uid}"
        update.message.reply_text(
            f"üëâ Maintenant, rejoins le canal {CANAL_LINK} et invite 3 amis via ce lien :\n{invite_link}\n\n"
            "‚ö†Ô∏è Tant que l'admin ne valide pas, ton acc√®s restera bloqu√©."
        )
        return

    # sinon : message neutre -> r√©pondre
    update.message.reply_text("Je n'ai pas compris. Utilise /start ou clique sur les boutons propos√©s.")

# ====== PREDICTION LOGIC ======
def prediction_cmd(update: Update, context: CallbackContext):
    uid = update.effective_user.id
    ensure_user(uid)
    user = users[uid]

    if user["status"] != "actif":
        update.message.reply_text("‚ö†Ô∏è Ton acc√®s est bloqu√©. Attends que l'admin te valide.")
        return

    now = time.time()
    # comportement demand√© :
    # - 3 minutes cooldown between predictions
    # - if press again in same minute (i.e. within 60s after last request), send "Pr√©diction en cours d'analyse..."
    last = user.get("last_prediction_ts", 0)
    elapsed = now - last

    if elapsed < 60:
        # within same minute -> "en cours d'analyse"
        update.message.reply_text("‚è≥ Pr√©diction en cours d'analyse... Attends quelques secondes.")
        return
    if elapsed < 180:
        # if between 60s and 3min -> tell to wait remaining
        remaining = int(180 - elapsed)
        update.message.reply_text(f"‚è≥ Please wait {remaining} secondes avant la prochaine pr√©diction.")
        return

    if user.get("pred_left", 0) <= 0:
        # plus de pr√©dictions: proposer achat
        keyboard = [
            [InlineKeyboardButton("Achetez", url=CONTACT_TELEGRAM)],
            [InlineKeyboardButton("V√©rifier l'achat", callback_data=f"verify_buy_{uid}")]
        ]
        update.message.reply_text(
            "‚ùå Ton volume de pr√©dictions est termin√©. Veux-tu acheter des signaux ?",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return

    # supprimer ancien message pr√©diction s'il existe
    if user.get("last_message_id"):
        try:
            context.bot.delete_message(chat_id=uid, message_id=user["last_message_id"])
        except:
            pass

    # G√©n√©rer une pr√©diction: 5 √©toiles dans chaque pr√©diction, positions al√©atoires (ici 5 √©toiles)
    board = [["üü¶" for _ in range(5)] for _ in range(5)]
    stars = random.sample([(i, j) for i in range(5) for j in range(5)], 5)
    for (i, j) in stars:
        board[i][j] = "‚≠êÔ∏è"
    text_grid = "\n".join("".join(row) for row in board)
    message_text = f"<b>üéØ Nouvelle pr√©diction</b>\n\n{text_grid}\n\n‚û°Ô∏è Mets les pi√®ges sur <b>3</b> !\n\n<b>Pr√©dictions restantes:</b> {user['pred_left']-1}"
    sent = update.message.reply_text(message_text, parse_mode=ParseMode.HTML)

    # mettre √† jour user
    user["last_message_id"] = sent.message_id
    user["last_prediction_ts"] = now
    user["pred_left"] -= 1

# ====== CALLBACK pour verify buy (lorsque user clique 'V√©rifier l'achat') ======
def callback_verify_buy(update: Update, context: CallbackContext):
    query = update.callback_query
    query.answer()
    data = query.data
    uid = query.from_user.id

    if data.startswith("verify_buy_"):
        # notifier admin: v√©rifier que l'achat a √©t√© effectu√© pour user
        parts = data.split("_")
        target = int(parts[2])
        msg = f"üì© L'utilisateur {target} dit avoir achet√© des signaux. Confirmer l'achat ?"
        kb = [
            [InlineKeyboardButton("Valide achat (+20)", callback_data=f"admin_confirm_buy_{target}")],
            [InlineKeyboardButton("Refuser", callback_data=f"admin_refuse_{target}")]
        ]
        context.bot.send_message(chat_id=TON_ID_ADMIN, text=msg, reply_markup=InlineKeyboardMarkup(kb))
        query.message.reply_text("‚úÖ Demande envoy√©e √† l'admin pour v√©rification de l'achat.")

# ====== ADMIN COMMANDS ======
def cmd_valider(update: Update, context: CallbackContext):
    if update.effective_user.id != TON_ID_ADMIN:
        update.message.reply_text("üö´ Tu n'es pas admin.")
        return
    if len(context.args) != 1:
        update.message.reply_text("Usage: /valider <user_id>")
        return
    try:
        target = int(context.args[0])
        ensure_user(target)
        users[target]["status"] = "actif"
        users[target]["pred_left"] = 20
        context.bot.send_message(chat_id=target, text="‚úÖ Ton compte a √©t√© valid√© par l'admin. Tu peux utiliser /prediction.")
        update.message.reply_text(f"‚úÖ {target} valid√©.")
    except Exception as e:
        update.message.reply_text("Erreur: impossible de valider.")

def cmd_refuser(update: Update, context: CallbackContext):
    if update.effective_user.id != TON_ID_ADMIN:
        update.message.reply_text("üö´ Tu n'es pas admin.")
        return
    if len(context.args) != 1:
        update.message.reply_text("Usage: /refuser <user_id>")
        return
    try:
        target = int(context.args[0])
        if target in users:
            users[target]["status"] = "bloque"
        context.bot.send_message(chat_id=target, text="‚ùå Ta demande a √©t√© refus√©e par l'admin.")
        update.message.reply_text(f"‚ùå {target} refus√©.")
    except:
        update.message.reply_text("Erreur: impossible de refuser.")

def cmd_liste(update: Update, context: CallbackContext):
    if update.effective_user.id != TON_ID_ADMIN:
        update.message.reply_text("üö´ Tu n'es pas admin.")
        return
    msg = "üìã Liste utilisateurs\n"
    for uid, u in users.items():
        msg += f"ID:{uid} | statut:{u['status']} | pred_left:{u['pred_left']}\n"
    update.message.reply_text(msg or "Aucun utilisateur.")

# ===== MAIN =====
def main():
    updater = Updater(TOKEN, use_context=True)
    dp = updater.dispatcher

    dp.add_handler(CommandHandler("start", start_cmd))
    dp.add_handler(CallbackQueryHandler(button_callback))            # boutons Commence / ask_id / admin validate/refuse / admin confirm buy
    dp.add_handler(CommandHandler("prediction", prediction_cmd))
    dp.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_text))

    # admin commands
    dp.add_handler(CommandHandler("valider", cmd_valider))
    dp.add_handler(CommandHandler("refuser", cmd_refuser))
    dp.add_handler(CommandHandler("liste", cmd_liste))

    # callback specific verify buy
    dp.add_handler(CallbackQueryHandler(callback_verify_buy, pattern=r"^verify_buy_"))

    updater.start_polling()
    logger.info("Bot d√©marr√©")
    updater.idle()

if __name__ == "__main__":
    main()
